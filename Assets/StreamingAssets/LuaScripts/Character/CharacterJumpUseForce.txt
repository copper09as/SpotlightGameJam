local GC = CS.GameController 
local DM = CS.DetectionManager

function CharacterJumpUseForce(entity, dt)
    local data = entity.dataTable
    local rb = entity.rb
    local inputJump = GC.isSpacePressed
    local rawFactor = entity.transform.localScale.x / 0.3
    local scaleFactor = rawFactor > 1 and rawFactor or 0.5 + 0.5 * rawFactor

    local origin = CS.UnityEngine.Vector2(
        entity.transform.position.x,
        entity.col.bounds.min.y
    )
    local groundCheck = DM.Raycast2D(origin, CS.UnityEngine.Vector2(0, -1), data.rayLen, "Ground")
    CS.UnityEngine.Debug.DrawRay(CS.UnityEngine.Vector3(origin.x, origin.y, 0), CS.UnityEngine.Vector3(0, -data.rayLen, 0), CS.UnityEngine.Color.red)

    dt = dt * data.jumpRate
    local currentHeight = entity.transform.position.y - (data.startY or entity.transform.position.y)

    -- âœ… èµ·è·³
    if inputJump and not data.jumpUsed and (groundCheck or (data.coyoteTimeCounter > 0)) and not data.isJumping then
        data.isJumping = true
        data.isJumpFalling = false
        data.jumpCut = false
        data.startY = entity.transform.position.y
        data.coyoteTimeCounter = 0
        data.jumpUsed = true
        Jump(entity, scaleFactor)  -- ğŸ†• èµ·è·³æ—¶æ’­æ”¾ Jump åŠ¨ç”»
    end

    -- æ¾å¼€ç©ºæ ¼
    if not inputJump then
        data.jumpUsed = false
    end

    -- åœŸç‹¼æ—¶é—´
    if groundCheck then
        data.coyoteTimeCounter = data.coyoteTime
    else
        data.coyoteTimeCounter = math.max(0, (data.coyoteTimeCounter or 0) - dt)
    end

    -- å»¶é•¿è·³è·ƒ
    if data.isJumping and inputJump then
        currentHeight = entity.transform.position.y - data.startY
        if currentHeight < data.maxJumpHeight then
            local addSpeed = data.gravity * dt * scaleFactor
            rb.velocity = CS.UnityEngine.Vector2(rb.velocity.x, rb.velocity.y + addSpeed)
        end
    end

    -- æ’å¢™åŠ¨èƒ½å‰Šå‡
    local leftOrigin = CS.UnityEngine.Vector2(entity.transform.position.x - entity.col.bounds.extents.x - 0.01, entity.transform.position.y)
    local rightOrigin = CS.UnityEngine.Vector2(entity.transform.position.x + entity.col.bounds.extents.x + 0.01, entity.transform.position.y)
    local wallCheckLeft = DM.Raycast2D(leftOrigin, CS.UnityEngine.Vector2(-1, 0), data.wallRayLen or 0.1, "Ground")
    local wallCheckRight = DM.Raycast2D(rightOrigin, CS.UnityEngine.Vector2(1, 0), data.wallRayLen or 0.1, "Ground")
    CS.UnityEngine.Debug.DrawRay(CS.UnityEngine.Vector3(leftOrigin.x, leftOrigin.y, 0), CS.UnityEngine.Vector3(-data.wallRayLen, 0, 0), CS.UnityEngine.Color.green)
    CS.UnityEngine.Debug.DrawRay(CS.UnityEngine.Vector3(rightOrigin.x, rightOrigin.y, 0), CS.UnityEngine.Vector3(data.wallRayLen, 0, 0), CS.UnityEngine.Color.green)

    if (wallCheckLeft or wallCheckRight) and rb.velocity.y > 0 then
        rb.velocity = CS.UnityEngine.Vector2(rb.velocity.x, math.max(0, rb.velocity.y - data.wallSlideDecay * dt))
    end

    -- ğŸª‚ ä¸Šå‡é˜¶æ®µ
    if data.isJumping then
        if currentHeight >= data.maxJumpHeight or data.jumpCut then
            rb.velocity = CS.UnityEngine.Vector2(rb.velocity.x, rb.velocity.y - data.gravity * data.jumpCutGravityMult * dt * scaleFactor)
        else
            if math.abs(rb.velocity.y) < data.jumpHangTimeThreshold then
                rb.velocity = CS.UnityEngine.Vector2(rb.velocity.x, rb.velocity.y - data.gravity * 0.5 * dt * scaleFactor)
            end
        end

        -- âœ¨ åœ¨è¿™é‡Œæ£€æµ‹â€œèµ·è·³åŠ¨ç”»â€ç»“æŸï¼Œä¸Šå‡è¿›å…¥â€œè·³è·ƒåœç•™â€
        if rb.velocity.y <= 0 then
            data.isJumping = false
            data.isJumpFalling = true
            -- ğŸ†• èµ·è·³åŠ¨ç”»ç»“æŸ â ç©ºä¸­å¾ªç¯ JumpStay
            if entity.animator then
                entity.animator:CrossFade("JumpStay", 0.1)
            end
        end
    end

    -- â¬‡ï¸ ä¸‹è½é˜¶æ®µ
    if data.isJumpFalling then
        rb.velocity = CS.UnityEngine.Vector2(rb.velocity.x, rb.velocity.y - data.gravity * data.fallGravityMult * dt * scaleFactor)
        if groundCheck then
            data.isJumpFalling = false
            rb.velocity = CS.UnityEngine.Vector2(rb.velocity.x, 0)
            data.jumpCut = false
            -- ğŸ†• è½åœ°å› Idle
            if entity.animator then
                entity.animator:CrossFade("Idle", 0.15)
            end
        end
    end
end

-- ğŸ†• åˆæ¬¡è·³è·ƒæ–½åŠ åŠ› + æ’­æ”¾ Jump åŠ¨ç”»
function Jump(entity, scaleFactor)
    local data = entity.dataTable
    local rb = entity.rb
    rb.velocity = CS.UnityEngine.Vector2(rb.velocity.x, data.jumpForce * scaleFactor)
    if entity.animator then
        entity.animator:CrossFade("Jump", 0.05) -- è¿‡æ¸¡çŸ­ä¸€ç‚¹ï¼Œæ‰‹æ„Ÿå¥½
    end
end

-- çŸ­æŒ‰è·³è·ƒåˆ¤æ–­
function AddJumpHeight(entity, jumpReleased)
    local data = entity.dataTable
    if jumpReleased and data.isJumping and entity.rb.velocity.y > 0 then
        data.jumpCut = true
    end
end

local GC = CS.GameController 
local DM = CS.DetectionManager

function CharacterJumpUseForce(entity, dt)
    local data = entity.dataTable
    local rb = entity.rb
    local inputJump = GC.isSpacePressed
    local rawFactor = entity.transform.localScale.x / 0.3
    local scaleFactor = rawFactor > 1 and rawFactor or 0.5 + 0.5 * rawFactor

    local origin = CS.UnityEngine.Vector2(
        entity.transform.position.x,
        entity.col.bounds.min.y
    )
    local groundCheck = DM.Raycast2D(origin, CS.UnityEngine.Vector2(0, -1), data.rayLen, "Ground")
    CS.UnityEngine.Debug.DrawRay(CS.UnityEngine.Vector3(origin.x, origin.y, 0), CS.UnityEngine.Vector3(0, -data.rayLen, 0), CS.UnityEngine.Color.red)

    dt = dt * data.jumpRate
    local currentHeight = entity.transform.position.y - (data.startY or entity.transform.position.y)

    -- ✅ 起跳
    if inputJump and not data.jumpUsed and (groundCheck or (data.coyoteTimeCounter > 0)) and not data.isJumping then
        data.isJumping = true
        data.isJumpFalling = false
        data.jumpCut = false
        data.startY = entity.transform.position.y
        data.coyoteTimeCounter = 0
        data.jumpUsed = true
        Jump(entity, scaleFactor)  -- 🆕 起跳时播放 Jump 动画
    end

    -- 松开空格
    if not inputJump then
        data.jumpUsed = false
    end

    -- 土狼时间
    if groundCheck then
        data.coyoteTimeCounter = data.coyoteTime
    else
        data.coyoteTimeCounter = math.max(0, (data.coyoteTimeCounter or 0) - dt)
    end

    -- 延长跳跃
    if data.isJumping and inputJump then
        currentHeight = entity.transform.position.y - data.startY
        if currentHeight < data.maxJumpHeight then
            local addSpeed = data.gravity * dt * scaleFactor
            rb.velocity = CS.UnityEngine.Vector2(rb.velocity.x, rb.velocity.y + addSpeed)
        end
    end

    -- 撞墙动能削减
    local leftOrigin = CS.UnityEngine.Vector2(entity.transform.position.x - entity.col.bounds.extents.x - 0.01, entity.transform.position.y)
    local rightOrigin = CS.UnityEngine.Vector2(entity.transform.position.x + entity.col.bounds.extents.x + 0.01, entity.transform.position.y)
    local wallCheckLeft = DM.Raycast2D(leftOrigin, CS.UnityEngine.Vector2(-1, 0), data.wallRayLen or 0.1, "Ground")
    local wallCheckRight = DM.Raycast2D(rightOrigin, CS.UnityEngine.Vector2(1, 0), data.wallRayLen or 0.1, "Ground")
    CS.UnityEngine.Debug.DrawRay(CS.UnityEngine.Vector3(leftOrigin.x, leftOrigin.y, 0), CS.UnityEngine.Vector3(-data.wallRayLen, 0, 0), CS.UnityEngine.Color.green)
    CS.UnityEngine.Debug.DrawRay(CS.UnityEngine.Vector3(rightOrigin.x, rightOrigin.y, 0), CS.UnityEngine.Vector3(data.wallRayLen, 0, 0), CS.UnityEngine.Color.green)

    if (wallCheckLeft or wallCheckRight) and rb.velocity.y > 0 then
        rb.velocity = CS.UnityEngine.Vector2(rb.velocity.x, math.max(0, rb.velocity.y - data.wallSlideDecay * dt))
    end

    -- 🪂 上升阶段
    if data.isJumping then
        if currentHeight >= data.maxJumpHeight or data.jumpCut then
            rb.velocity = CS.UnityEngine.Vector2(rb.velocity.x, rb.velocity.y - data.gravity * data.jumpCutGravityMult * dt * scaleFactor)
        else
            if math.abs(rb.velocity.y) < data.jumpHangTimeThreshold then
                rb.velocity = CS.UnityEngine.Vector2(rb.velocity.x, rb.velocity.y - data.gravity * 0.5 * dt * scaleFactor)
            end
        end

        -- ✨ 在这里检测“起跳动画”结束，上升进入“跳跃停留”
        if rb.velocity.y <= 0 then
            data.isJumping = false
            data.isJumpFalling = true
            -- 🆕 起跳动画结束 ➝ 空中循环 JumpStay
            if entity.animator then
                entity.animator:CrossFade("JumpStay", 0.1)
            end
        end
    end

    -- ⬇️ 下落阶段
    if data.isJumpFalling then
        rb.velocity = CS.UnityEngine.Vector2(rb.velocity.x, rb.velocity.y - data.gravity * data.fallGravityMult * dt * scaleFactor)
        if groundCheck then
            data.isJumpFalling = false
            rb.velocity = CS.UnityEngine.Vector2(rb.velocity.x, 0)
            data.jumpCut = false
            -- 🆕 落地回 Idle
            if entity.animator then
                entity.animator:CrossFade("Idle", 0.15)
            end
        end
    end
end

-- 🆕 初次跳跃施加力 + 播放 Jump 动画
function Jump(entity, scaleFactor)
    local data = entity.dataTable
    local rb = entity.rb
    rb.velocity = CS.UnityEngine.Vector2(rb.velocity.x, data.jumpForce * scaleFactor)
    if entity.animator then
        entity.animator:CrossFade("Jump", 0.05) -- 过渡短一点，手感好
    end
end

-- 短按跳跃判断
function AddJumpHeight(entity, jumpReleased)
    local data = entity.dataTable
    if jumpReleased and data.isJumping and entity.rb.velocity.y > 0 then
        data.jumpCut = true
    end
end
